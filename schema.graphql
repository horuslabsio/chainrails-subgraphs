type Intent @entity {
    id: ID!
    intentAddress: String!
    sourceChain: Int!
    destinationChain: Int!
    bridgeTokenOutOptions: [TokenAmount!]!
    destinationRecipient: String!
    coordinator: String!
    bridger: String!
    refundAddress: String!
    nonce: BigInt!
    expirationTimestamp: BigInt!
    needsRelay: Boolean
    metadata: String!
    status: IntentStatus!
    totalFunded: BigInt!
    fundingTransactions: [FundingTransaction!]! @derivedFrom(field: "intent")
}

type FundingTransaction @entity {
    id: ID! # tx_hash-log_index
    intent: Intent!
    token: Token!
    amount: BigInt!
    chainId: Int!
    tokenAddress: String! # Keep for backward compatibility and easy querying
}

type TokenAmount @entity {
    id: ID!
    token: String!
    amount: BigInt!
    intent: Intent!
}

type Token @entity {
    id: ID! # token address
    address: String!
    symbol: String
    name: String
    decimals: Int
    chainId: Int!
    fundingTransactions: [FundingTransaction!]! @derivedFrom(field: "token")
}

enum IntentStatus {
    PENDING
    FUNDED
    INITIATED
    COMPLETED
}

enum BroadcastStatus {
    PENDING
    EXECUTED
    CANCELLED
}

type Broadcast @entity {
    id: ID!
    broadcastId: Bytes!
    sender: Bytes!
    sourceChain: Int!
    destinationChain: Int!
    destinationRecipient: Bytes!
    refundAddress: Bytes!
    broadcaster: Bytes!
    broadcastingContract: Bytes!
    isLive: Boolean!
    status: BroadcastStatus!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    transactionHash: Bytes!
    deposits: [BroadcastDeposit!]! @derivedFrom(field: "broadcast")
    bridgeTokenOutOptions: [BroadcastTokenAmount!]! @derivedFrom(field: "broadcast")
}

type BroadcastDeposit @entity {
    id: ID!
    broadcast: Broadcast!
    token: Bytes!
    amount: BigInt!
}

type BroadcastTokenAmount @entity {
    id: ID!
    broadcast: Broadcast!
    token: Bytes!
    amount: BigInt!
}
